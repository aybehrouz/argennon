%! Author = aybehrouz


\section{Applications}\label{sec:applications}

An Argennon application or smart contract is an HTTP server which is represented by an Argennon Standard
Representation (ASR) and whose state is stored in the Argennon blockchain. Each Argennon application is identified by
a unique application identifier.

An application identifier, \texttt{applicationID}, is
a unique prefix code generated by the \emph{applications} prefix tree. (See Section~\ref{sec:identifiers}.)
An application identifier can be considered as the address of an application and has the following standard symbolic
representation:
\begin{verbatim}
<application-id> ::= <decimal-prefix-code>
<decimal-prefix-code> ::= <dec-num>"."<decimal-prefix-code> | <dec-num>
\end{verbatim}
where \texttt{<dec-num>} is a normal decimal number between $0$ and $255$. For example \texttt{21.255.37},
\texttt{0}, \texttt{11.6} and \texttt{2.0.0.0.0}, are valid application addresses.

Argennon has two special smart contracts: the \emph{root smart contract}, also called the \emph{root application}, and
the \emph{ARG smart contract}, which is also called the \emph{Argennon smart contract} or the \emph{ARG application}.

Argennon application use HTTP as the application protocol and they are advised to have a RESTful API design.

\subsection{The Root Application}\label{subsec:the-root-app}

The root application or the root smart contract, with \texttt{applicationID = 0}, is a privileged smart contract
responsible for installation/uninstallation of other smart contracts. The Argennon's root smart contract
performs three main operations:

\begin{itemize}
    \item Installation of new Argennon applications and determining the update policy of a smart
    contract: if the contract is updatable or not, which accounts or smart contracts can update or uninstall
    the contract, and so on.
    \item Removing an Argennon application (if allowed).
    \item Updating an Argennon application (if allowed).
\end{itemize}

The root smart contract is a mutable smart contract and can be updated by the Argennon governance system.
(See Section~\ref{sec:adags})

\subsection{The ARG Application}\label{subsec:the-arg-app}

The ARG application or the ARG smart contract,
with \texttt{applicationID = 1}, controls the ARG token, the main
currency of the Argennon blockchain. This smart contract also manages a database of public keys and
handles signature verification.

The ARG smart contract is a mutable smart contract and can be updated by the Argennon governance system.


\section{Accounts}\label{sec:accounts}

Argennon accounts are entities defined inside the ARG application.
Every Argennon account is uniquely identified by a prefix code generated using \emph{accounts} prefix
tree. (See Section~\ref{sec:identifiers}) An account
identifier can be considered as the address of an account and has the following standard symbolic representation:
\begin{verbatim}
<account-id> ::= "0x"<hex-num>
\end{verbatim}
where \texttt{<hex-num>} is a hexadecimal number, using lower case
letters \texttt{[a-f]} for showing digits greater than $9$.

For example \texttt{0x24ffda}, \texttt{0x0} and \texttt{0x03a0000}, are valid standard symbolic
representations of account addresses.

A new account can be created by sending a proper HTTP request to the ARG smart contract. For creating
a new account two public keys need to be provided by the caller and registered in the Argennon smart contract.
One public key will be used for issuing digital signatures, and the other one will be used for voting. The
provided public keys need to meet certain cryptographic requirements,\footnote{Argennon uses Prove
Knowledge of the Secret Key (KOSK) scheme.} and can not be already registered in the system.

If the owner of the new account is an application, the \texttt{applicationID} of the owner will be registered in the
ARG smart contract and no public keys are needed. An application can own an arbitrary number of accounts.

\note{Explicit key registration enables Argennon to decouple cryptography from the blockchain design. In this way,
    if the cryptographic algorithms used become insecure for some reason, for example because
    of the introduction of quantum computers, they could be easily upgraded.}


\section{Transactions}\label{sec:transactions}

An Argennon transaction consist of an HTTP request made by a user to an Argennon application, a resource
declaration object and a list of signed messages. Transactions can only be
issued by users and applications can not create transactions. An Argennon transaction is also called
an \emph{external request}.

\subsection{Resource Declaration}\label{subsec:resource-declaration}

Every Argennon transaction is required to provide the following information as an upper bound for the
resources it needs:

\begin{itemize}
    \item Maximum AscEE clocks
    \item The list of applications the request will call
    \item The list of access blocks the request needs
    \item \texttt{maxSize} for chunks it wants to expand
    \item \texttt{minSize} for chunks it wants to shrink
    \item A list of applications it will update (if any)
\end{itemize}

If a transaction tries to violate any of these predefined limitations, it will be considered failed, and the network
can receive the proposed fee of that transaction.

\begin{lstlisting}[language=python, frame=TB, float, title=An Argennon transaction in YAML format,
    label={lst:txn-example}]
---
request: |
    PATCH /balances/0x95ab HTTP/1.1
    Content-Type: application/json; charset=utf-8
    Content-Length: 46

    {"to":0xaabc,"amount":1399,"sig":0}

messages:
   - issuer: 0x95ab000000000000
     msg: {"to":0xaabc000000000000,"amount":1399,"forApp":0x100000000000000,"nonce":11}
     sig: LNUC49Lhyz702uszzNcfaU3BhPIbdaSgzqDUKzbJzLPTlFS2J9GzHl-cDKb

caps:
    maxClocks: 150 # maximum number of AVM execution clocks
    apps: [1,124.16]
    read: [(2654,3),(15642,0),(15642,1),(15642,3)]
    write: [(15642,0),(20154,0),(20154,1)]
\end{lstlisting}


\section{Resource Management}\label{sec:res-man}

Completing an execution session requires computational resources. The amount of resources used by an execution session
should be monitored and managed, otherwise a malicious user would be able to easily spam and exhaust resources of the
execution environment.

In most consensus protocols, we can assume that the block proposer has enough incentive to filter out transactions
that spam run-time resources. Here by a run-time resource, we mean a resource that at run-time, a limited amount
of it is available, but its surplus can not be stored for later use. Execution time and local memory are
examples of such a resource but permanent storage is not.

If a proposed block contains many transactions which need a lot of run-time resources, validators would not
be able to validate all transactions in a timely manner. Consequently, they may decide to reject the block or if they
spend enough resources, the confirmation of that block could take more than usual. Longer block time is not
favoured by block proposers, because it means less throughput of the system which usually means less overall rewards
for them. In the Argennon protocol the management of run-time resources, is left to the block proposer.

Resource usage can be measured per session or per application call. Obviously per session measurement is
easier and more efficient. However, when we measure resources per session if
a session violates its resource caps, determining the point of failure may require precise and error-free resource
measurement. For example, assume that a session containing an application call
violates a 2 milliseconds execution time cap. If in the caller's code, the call happens exactly after 2 milliseconds,
a small fluctuation in the execution time measurement can
change the point of failure between the called and the caller application. Note that for implementing optional
decoupling principle in Argennon, we need to determine the
exact application call which has failed in a call chain, and this fluctuation introduces a nondeterministic
behaviour which could make block validation impossible. That's why we need per application call
resource management sometimes. If we define the resource caps per application call and
perform our measurements for each application call separately, by using caps that are larger than the measurement
error, errors in the measurements would not change the point of failure in the call chain.

The AscEE has two types of execution sessions: \emph{optimistic} and \emph{monitored}. Resource usage of an optimistic
session is always measured per session and \textbf{default} pre-defined resource caps are used. On the other hand, for a
monitored session, resources that can not be measured precisely are measured per application call and their caps are
determined per application call by the external HTTP request (i.e.\ transaction). The block proposer decides the
type of the execution session for each transaction.


Different computational resources are measured and monitored during an AscEE session:
\begin{itemize}
    \item \textbf{execution time}:
    is the amount of cpu time that is required for executing a session or an application call. The execution time is
    measured in \emph{AscEE clocks}. One AscEE clock is defined as 1/1000 of the amount
    of \textbf{cpu time} needed for executing a predefined standard application which is used for benchmarking a host's
    performance. In other words, by definition, the AscEE imaginary standard machine completes the standard benchmark
    in 1000 clocks.

    Optimistic sessions have a predefined \texttt{maxClocks} value which is determined by the Argennon protocol. This
    value defines a bound on the \textbf{total} AscEE clocks of the session, and no per application measurement is done.

    Monitored sessions perform per application call cpu-time measurement, and every application call during a monitored
    session has a separate \texttt{maxClocks} value. This value determines the maximum amount of time that the cpu
    can be used for executing that particular application call. It should be noted that the cpu timer of the
    application call is paused when the application makes a call to another application, and is resumed when the
    control returns. An application call
    needs at least 10 clocks and if the value of its \texttt{maxClock} is lower than this value the call will be
    considered a failed call.

    Each application call has some amount of \texttt{externalClocks}. When an application makes a request to another
    application it has to \emph{forward} a portion of its \textbf{external} clocks to the called application. This
    amount will determine the value of \texttt{maxClocks} for the called application, and is subtracted from the value
    of \texttt{externalClocks} of the caller.

    The amount of external clocks of an application
    call is defined to be \(2/3\) of its \texttt{maxClocks}. As a result, the total number of clocks of a monitored
    session is always less than \(3 \times \texttt{maxClocks}\) of the root application call. The value of
    \texttt{maxClocks} for
    the root application call is determined by the external request (i.e.\ transaction).

    \item \textbf{local memory}:
    any memory usage of an application that is not part of a heap chunk and is not part of another measured resource
    will be considered as local memory usage. Local memory is not persistent and when an application finishes serving a
    request and returns the HTTP response (i.e.\ the application call completes) its local memory is deleted.
    This resource is measured in bytes.

    Optimistic sessions measure local memory usage per session and enforce a protocol-defined cap on the total amount
    of local memory a session can use. Monitored sessions measure local memory usage per
    application call and enforce a protocol-defined cap for each application call separately. An application call
    which tries to use more local memory than the cap, fails.
    \item \textbf{heap access list}:
    every session can only access heap locations that are declared in its access list. In addition,
    resizing heap chunks can only be done in the range of the pre-declared lower bound and upper bound.
    \item \textbf{app access list}:
    a session may only make requests to applications that are declared in its application access list.
    \item \textbf{call depth}:
    during a session the number of nested application calls can not be more than a threshold. This threshold is
    determined by the Argennon protocol. It should be noted that a differed call is considered like a normal call and
    increases the call depth by one level.
    \item \textbf{differed calls}:
    every application call can have a limited number of differed calls which is determined by the protocol.
    To simplify the implementation, this limit is defined per application call. Since in Argennon the call depth is
    limited, a per-application call limit will also define an implicit limit for the total number of active differed
    calls.
    \item \textbf{virtual signatures}:
    \item \textbf{number of entrance locks}:
\end{itemize}

In Argennon, execution time and local memory are considered \emph{nondeterministic} resources. A nondeterministic
resource is a resource that can not be measured precisely and its measurement always contains a random error.
Optimistic sessions are not allowed to fail because of violating nondeterministic resource limits. As a result, the
block proposer must always choose a monitored session for a transaction that is included in the block and violates a
nondeterministic resource cap.

When a transaction fails due to the violation of a limit for a nondeterministic resource, the proposer is
required to exactly specify the application call which violates that limit in the execution session. When validators are
executing a monitored session, for each application call, they enforce considerably larger limits for
nondeterministic resources. Only in case the proposer has declared that an application call violates a limit, the
validators will enforce the actual value of the limit. This simple mechanism ensures that, with a very high
probability, validators agree with the proposer, although their measurements could be different.

