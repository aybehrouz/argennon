%! Author = aybehrouz


\section{Applications}\label{sec:applications}

An Argennon application or smart contract is an HTTP server which is represented by an Argennon Standard Application
Representation (ASAR) and whose state is stored in the Argennon blockchain. Each Argennon application is identified by
a unique application identifier.

An application identifier, \texttt{applicationID}, is
a unique prefix code generated by the \emph{applications} prefix tree. (See Section~\ref{sec:identifiers}.)
An application identifier can be considered as the address of an application and has the following standard symbolic
representation:
\begin{verbatim}
<application-id> ::= <decimal-prefix-code>
<decimal-prefix-code> ::= <dec-num>"."<decimal-prefix-code> | <dec-num>
\end{verbatim}
where \texttt{<dec-num>} is a normal decimal number between $0$ and $255$. For example \texttt{21.255.37},
\texttt{0}, \texttt{11.6} and \texttt{2.0.0.0.0}, are valid application addresses.

Argennon has two special smart contracts: the \emph{root smart contract}, also called the \emph{root application}, and
the \emph{ARG smart contract}, which is also called the \emph{Argennon smart contract} or the \emph{ARG application}.

Argennon application use HTTP as the application protocol and they are advised to have a RESTful API design.

\subsection{The Root Application}\label{subsec:the-root-app}

The root application or the root smart contract, with \texttt{applicationID = 0}, is a privileged smart contract
responsible for installation/uninstallation of other smart contracts. The Argennon's root smart contract
performs three main operations:

\begin{itemize}
    \item Installation of new Argennon applications and determining the update policy of a smart
    contract: if the contract is updatable or not, which accounts or smart contracts can update or uninstall
    the contract, and so on.
    \item Removing an Argennon application (if allowed).
    \item Updating an Argennon application (if allowed).
\end{itemize}

The root smart contract is a mutable smart contract and can be updated by the Argennon governance system.
(See Section~\ref{sec:adags})

\subsection{The ARG Application}\label{subsec:the-arg-app}

The ARG application or the ARG smart contract,
with \texttt{applicationID = 1}, controls the ARG token, the main
currency of the Argennon blockchain. This smart contract also manages a database of public keys and
handles signature verification.

The ARG smart contract is a mutable smart contract and can be updated by the Argennon governance system.


\section{Accounts}\label{sec:accounts}

Argennon accounts are entities defined inside the ARG application.
Every Argennon account is uniquely identified by a prefix code generated using \emph{accounts} prefix
tree. (See Section~\ref{sec:identifiers}) An account
identifier can be considered as the address of an account and has the following standard symbolic representation:
\begin{verbatim}
<account-id> ::= "0x"<hex-num>
\end{verbatim}
where \texttt{<hex-num>} is a hexadecimal number, using lower case
letters \texttt{[a-f]} for showing digits greater than $9$.

For example \texttt{0x24ffda}, \texttt{0x0} and \texttt{0x03a0000}, are valid standard symbolic
representations of account addresses.

A new account can be created by sending a proper HTTP request to the ARG smart contract. For creating
a new account two public keys need to be provided by the caller and registered in the Argennon smart contract.
One public key will be used for issuing digital signatures, and the other one will be used for voting. The
provided public keys need to meet certain cryptographic requirements,\footnote{Argennon uses Prove
Knowledge of the Secret Key (KOSK) scheme.} and can not be already registered in the system.

If the owner of the new account is an application, the \texttt{applicationID} of the owner will be registered in the
ARG smart contract and no public keys are needed. An application can own an arbitrary number of accounts.

\note{Explicit key registration enables Argennon to decouple cryptography from the blockchain design. In this way,
    if the cryptographic algorithms used become insecure for some reason, for example because
    of the introduction of quantum computers, they could be easily upgraded.}


\section{External Requests}\label{sec:transactions}

An Argennon \emph{external request} (i.e.\ transaction) consist of an HTTP request made by a user to an Argennon application, a
resource declaration object and a list of signed messages. External requests can only be
issued by users and requests created by applications are called \emph{internal request}.

\subsection{Resource Declaration}\label{subsec:resource-declaration}

Every Argennon transaction is required to provide the following information as an upper bound for the
resources it needs:

\begin{itemize}
    \item Maximum AscEE clocks
    \item The list of applications the request will call
    \item The list of access blocks the request needs
    \item \texttt{maxSize} for chunks it wants to expand
    \item \texttt{minSize} for chunks it wants to shrink
    \item A list of applications it will update (if any)
\end{itemize}

If a transaction tries to violate any of these predefined limitations, it will be considered failed, and the network
can receive the proposed fee of that transaction.

\begin{lstlisting}[language=python, frame=TB, float, title=An Argennon transaction in YAML format,
    label={lst:txn-example}]
---
request: |
    PATCH /balances/0x95ab HTTP/1.1
    Content-Type: application/json; charset=utf-8
    Content-Length: 46

    {"to":0xaabc,"amount":1399,"sig":0}

messages:
   - issuer: 0x95ab000000000000
     msg: {"to":0xaabc000000000000,"amount":1399,"forApp":0x100000000000000,"nonce":11}
     sig: LNUC49Lhyz702uszzNcfaU3BhPIbdaSgzqDUKzbJzLPTlFS2J9GzHl-cDKb

caps:
    maxClocks: 150 # maximum number of AVM execution clocks
    apps: [1,124.16]
    read: [(2654,3),(15642,0),(15642,1),(15642,3)]
    write: [(15642,0),(20154,0),(20154,1)]
\end{lstlisting}


\section{Resource Management}\label{sec:res-man}

Completing an execution session requires computational resources. The amount of resources used by an execution session
should be monitored and managed, otherwise a malicious user would be able to easily spam and exhaust resources of the
execution environment.

In most consensus protocols, we can assume that the block proposer has enough incentive to filter out transactions
that spam run-time resources. Here by a run-time resource, we mean a resource that at run-time, a limited amount
of it is available, but its surplus can not be stored for later use. Execution time and local memory are
examples of such a resource but permanent storage is not.

If a proposed block contains many transactions which need a lot of run-time resources, validators would not
be able to validate all transactions in a timely manner. Consequently, they may decide to reject the block or if they
spend enough resources, the confirmation of that block could take more than usual. Longer block time is not
favoured by block proposers, because it means less throughput of the system which usually means less overall rewards
for them. In the Argennon protocol the management of run-time resources, is left to the block proposer.

In Argennon the reference for resource usage is the Argennon Prover Machine. The APM has two different execution
units: the NEU which is used for executing external requests that the block proposer claims will complete
successfully and the FRU which executes requests that the proposer has classified as failed requests. The FRU has a
more restricted resource management and less resources are available for requests that use the FRU.

We recall from Chapter~\ref{ch:APM} that the APM configuration is a tuple:
\[
(\mathcal{S},\mathcal{L}_{\text{NEU}},\mathcal{L}_{\text{FRU}},\mathcal{T}_{\text{NEU}},\mathcal{T}_{\text{FRU}}).
\]
When requests are executed by the APM, the following run-time resources should be considered:

\begin{itemize}
    \item \textbf{execution cost}:
    each APM instruction has a protocol defined cost and the execution cost of a program can be calculated
    deterministically. Only the FRU performs these calculations and verifies that an external request does not exceed
    its predeclared execution cost.

    For executing all request of a block, at max, The NEU will run for
    $\mathcal{T}_{\text{NEU}}$ steps and the FRU will run for
    $\mathcal{T}_{\text{FRU}}$ steps.

    \item \textbf{local memory}: $\mathcal{L}_{\text{NEU}}, \mathcal{L}_{\text{FRU}}$. The Argennon protocol requires
    $\mathcal{L}_{\text{NEU}} = 3\mathcal{L}_{\text{FRU}}$, so the NEU has three times more local memory.

    \item \textbf{stack size}: both the FPU and the NEU has the same stack size: $\mathcal{S}$

    \item \textbf{heap access list}:
    every session can only access heap locations that are declared in its access list. In addition,
    resizing heap chunks can only be done in the range of the pre-declared lower bound and upper bound. Both the NEU
    and the FRU enforce this restriction.
    \item \textbf{app access list}:
    a session may only make requests to applications that are declared in its application access list. Both the NEU
    and the FRU enforce this restriction.
    \item \textbf{call depth}:
    during a session the number of nested application calls can not be more than a threshold. This threshold is
    determined by the Argennon protocol. It should be noted that a differed call is considered like a normal call and
    increases the call depth by one level. Only the FRU enforces this restriction.
\end{itemize}

In Argennon the proposer does not use the APM for executing requests and directly executes the ASAR of an
application, which is much more efficient. Only when he wants to reject a transaction because of excessive resource
usage, he will emulate the APM to make sure that the request will be rejected by the FRU. The differences between the
NEU and FRU ensures that this policy is safe.